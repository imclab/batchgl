{"name":"BatchGL","tagline":"A library for easy WebGL batching.","body":"BatchGL\r\n================================================================================\r\n\r\nA library that makes high-performance batched WebGL calls easy.\r\n\r\nBatchGL models a series of WebGL calls as a tree with vertex data buffered into\r\nthe leaves. It renders the tree depth-first, so buffered vertices in leaves\r\nwill get batched over together.  Leaves closer to each other will get rendered\r\nmore closely to each other, allowing for fewer expensive context switches,\r\ntexture buffering, etc.\r\n\r\n\r\nInstallation\r\n--------------------------------------------------------------------------------\r\n\r\n`bower install batchgl` or `npm install batchgl`\r\n\r\nYou can use the `build/batchgl.js` file as-is, or run `npm install && make\r\nbuild` to get the minified and gzipped versions.\r\n\r\n\r\nExamples\r\n--------------------------------------------------------------------------------\r\n\r\nHere's how you might set up a texture-rendering pipeline:\r\n\r\n```javascript\r\n\r\n/*\r\n * One-time setup of the rendering pipeline starts here:\r\n */\r\n\r\nvar Program = BatchGL.Root.extend({\r\n  init: function(context, vertexShader, fragmentShader) {\r\n    // compile shaders, link program here\r\n  },\r\n  run: function() {\r\n    // tell WebGL to use the program\r\n  }\r\n});\r\n\r\nvar Texture = BatchGL.Step.extend({\r\n  init: function(program, image) {\r\n    // setup\r\n  },\r\n  run: function() {\r\n    // buffer, bind textures\r\n  }\r\n});\r\n\r\nvar Uniform = BatchGL.Leaf.extend({\r\n  init: function() {\r\n    // setup\r\n  },\r\n\r\n  run: function() {\r\n    // bind uniforms here\r\n  },\r\n\r\n  buffer: function(vertexSet) {\r\n    // buffer vertices to WebGL\r\n  },\r\n\r\n  flush: function() {\r\n    // call WebGL drawing methods\r\n  }\r\n});\r\n\r\nvar context = new BatchGL.Context(canvas),\r\n    program = new Program(context, vertexShader, fragmentShader),\r\n    sprite = new Texture(program, spriteSheet),\r\n    otherSprite = new Texture(program, spriteSheet2),\r\n    lion = new Uniform(sprite, someCoordinates),\r\n    tiger = new Uniform(sprite, otherCoordinates),\r\n    bear = new Uniform(otherSprite, otherOtherCoordinates);\r\n\r\n\r\n/*\r\n * One-time setup is finished. You can now create sets of vertices pointing to\r\n * different leaves in the pipeline tree, and pass them around as renderable\r\n * objects.\r\n */\r\n\r\nvar v1 = new BatchGL.VertexSet(lion, [ /* some vertices */ ]);\r\nvar v2 = new BatchGL.VertexSet(lion, [ /* more vertices */ ]);\r\nvar v3 = new BatchGL.VertexSet(tiger, [ /* more vertices */ ]);\r\nvar v4 = new BatchGL.VertexSet(bear, [ /* more vertices */ ]);\r\nvar v5 = new BatchGL.VertexSet(bear, [ /* more vertices */ ]);\r\n\r\n/*\r\n * You can buffer vertices in any order: BatchGL will optimize the underlying\r\n * calls so that it doesn't matter.\r\n */\r\n\r\nv1.buffer();\r\nv5.buffer();\r\nv4.buffer();\r\nv3.buffer();\r\nv2.buffer();\r\n\r\n\r\n/*\r\n * The following renders any buffered vertices. It optimizes the underlying\r\n * WebGL buffering and drawing according to the rendering tree set up above, to\r\n * maximize batching and to minimize expensive context switches.\r\n */\r\n\r\nprogram.render();\r\n```\r\n\r\n\r\nAPI Docs\r\n--------------------------------------------------------------------------------\r\n\r\n### BatchGL.Context\r\n\r\nThe BatchGL Context object holds a reference to a `<canvas>` element and its\r\ncorresponding WebGL context.\r\n\r\n#### Methods:\r\n\r\n* `new Context(canvas)`. The Context constructor takes a canvas object and\r\n  initializes its `gl` object by calling the HTML5 `getContext` method.\r\n* `.updateSize()`. This updates the `width` and `height` properties of the\r\n  `<canvas>` element to be equal to their container's CSS box-sizing. It also\r\n  updates the WebGL viewport to be the same.\r\n\r\n#### Public Properties\r\n\r\n* `canvas`, the `<canvas>` element.\r\n* `gl`, the WebGL context object.\r\n\r\n\r\n### BatchGL.TreeNode\r\n\r\nTreeNode is the base class for any of the classes that make up the BatchGL\r\nrendering tree: `Root`, `Step`, and `Leaf`. TreeNodes are never instantiated\r\ndirectly, and are just a convenient holding place for shared callback stubs.\r\n\r\n#### Class Methods:\r\n\r\n* `.extend(Derived)` sets up the prototype chain so that Derived extends the\r\n  class, and also copies over any class methods from the base class to Derived.\r\n  If Derived is a function, it will use the function as the constructor; if\r\n  Derived is an object, it will create a constructor, make it extend the base\r\n  class, and then add any properties from the given object to the derived\r\n  constructor's prototype. In any case, it returns the derived constructor\r\n  function.\r\n\r\n#### Public Methods:\r\n\r\n* `new TreeNode()`. The TreeNode constructor takes any number of arguments, and\r\n  passes them all to its overridable `init` method.\r\n* `.init()`, a method stub. Client code can override the `init` method to do\r\n  something when a node is initialized.\r\n* `.run()`, a method stub. Client code can override the `run` method to do work\r\n  when BatchGL is processing a `render` call and has reached the current node in\r\n  the tree.\r\n\r\n#### Framework-Reserved Methods\r\n\r\n* `.render()`, a method stub that gets overridden by the derived node classes.\r\n  Client code probably shouldn't override this method. `render` is called to\r\n  render the current node.\r\n\r\n\r\n### BatchGL.Root\r\n\r\nThe Root class defines the roots of rendering trees. You might set up a WebGL\r\nprogram in the root, and use it for all subsequent calls; if you have multiple\r\nprograms, you might not do much here at all except for some basic environment\r\nsetup.\r\n\r\n#### Public Methods\r\n\r\n* `new Root(context)` creates a new Root object for the given Context object.\r\n  It also calls the overridable `.init()` method inherited from TreeNode.\r\n* `.render()` calls the `.run()` method, and then calls `render` on all of the\r\n  root's children.\r\n\r\n#### Framework-Reserved Methods\r\n\r\n* `.add(child)` adds a TreeNode child to the Root. Steps (and Leaves) call this\r\n  method automatically on their parents, so you shouldn't need to call this\r\n  method manually when constructing a rendering tree.\r\n\r\n#### Public Properties\r\n\r\n* `context` holds the Context object for the root.\r\n\r\n\r\n### BatchGL.Step\r\n\r\nThe Step class is for intermediate steps in the rendering tree. For example,\r\nyou might bind textures in a step, which would ensure that any calls to the\r\nleaves beneath them would be batched into a single texture binding call. If\r\nyou're using multiple programs, you probably want the programs to be\r\nimplemented as Step classes underneath a single Root.\r\n\r\n#### Public Methods\r\n\r\n* `new Step(parent)` creates a new Step object underneath the given parent Root\r\n  or Step node. It also calls the overridable `.init()` method inherited from\r\n  TreeNode.\r\n* `.render()`, much like the Root object, calls the Step's `run()` method and\r\n  then calls `render` on all of its children.\r\n\r\n#### Framework-Reserved Methods\r\n\r\n* `.add(child)`, like the Root's `.add()` method, adds a TreeNode child to the\r\n  Step. Since Steps and Leaves call this automatically in their constructors,\r\n  you shouldn't need to call this manually when constructing a rendering tree.\r\n\r\n#### Public Properties\r\n\r\n* `context` is the Step's Context object.\r\n* `parent` is the Step's parent.\r\n\r\n\r\n### BatchGL.Leaf\r\n\r\nThe Leaf class defines the leaves of a rendering tree, and are what do the\r\nactual buffering and drawing of vertices. Leaves should ideally be cheap to\r\nswitch: binding things like uniforms here is a good idea.\r\n\r\n#### Public Methods\r\n\r\n* `new Leaf(parent)` creates a new Leaf object underneath the given Root or\r\n  Step parent. It also calls the overridable `.init()` method inherited from\r\n  TreeNode.\r\n* `.buffer(vertexSet)` is an overriddable method stub for buffering VertexSet\r\n  instances. You should put WebGL buffering calls in here.\r\n* `flush()` is an overridable method stub for flushing buffered vertices. You\r\n  should put WebGL draw calls here.\r\n* `.render()`, much like the other TreeNode rendering methods, calls the Leaf's\r\n  `.run()` method. However, the similarities stop there: it then calls its own\r\n  `.buffer()` method on each buffered VertexSet, and assuming that it buffered\r\n  some vertices, then calls `.flush()`.\r\n\r\n#### Framework-Reserved Methods\r\n\r\n* `._bufferVertex()` buffers a VertexSet into the Leaf's rendering queue.\r\n  VertexSets call this method automatically when you call their `.buffer()`\r\n  method, so you should never have to call this yourself.\r\n\r\n#### Public Properties\r\n\r\n* `parent` is the Leaf's TreeNode parent.\r\n* `context` is the Leaf's Context object.\r\n\r\n\r\n### BatchGL.VertexSet\r\n\r\nThe VertexSet class defines a set of vertices for a particular leaf in the\r\nrendering tree. VertexSets are easy objects to pass around, and you can just\r\ncall their `.buffer()` method when you want to tell the rendering tree that you\r\nwant to render the set. Whenever you want to flush the frame, calling\r\n`.render()` on the tree's root node will flush all of the buffered vertices.\r\n\r\n#### Public Methods\r\n\r\n* `new VertexSet(leaf, vertices)` creates a new VertexSet for the given leaf.\r\n  The vertices array is an optional array of numeric vertices; if you don't\r\n  pass one into the constructor, you'll have to pass one in later with a\r\n  `.setVertices` call before attempting to buffer the set.\r\n* `.setVertices(vertices)` takes an array of numeric vertices, and creates a\r\n  Float32Array out of them and assigns it to the `vertices` property.\r\n* `.buffer()` buffers the vertex into its Leaf parent for rendering. Note that\r\n  it won't actually be rendered until a subsequent `.render()` call on the root\r\n  of the rendering tree (which you should probably call at the end of your\r\n  frame).\r\n\r\n#### Public Properties\r\n\r\n* `leaf` is the parent Leaf object.\r\n* `vertices` is a Float32Array of vertices.\r\n\r\n\r\n\r\nDevelopment Notes\r\n--------------------------------------------------------------------------------\r\n\r\nTo run the tests, make sure you've run an `npm install` at some point, and then\r\nrun `script/test 8000` (or pass in the numerical port of your choice).\r\n\r\nIf you want to peruse the code, tell me about bugs, or submit patches: [a link\r\nto the repo](https://github.com/reissbaker/batchgl).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}